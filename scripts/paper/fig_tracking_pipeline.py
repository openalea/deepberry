import os
import pandas as pd
import cv2
import matplotlib.pyplot as plt
import numpy as np

from deepberry.src.openalea.deepberry.utils import ellipse_interpolation

# where files generated by this script are saved
DIR_OUTPUT = 'data/grapevine/paper/fig_tracking_pipeline/'
if not os.path.isdir(DIR_OUTPUT):
    os.mkdir(DIR_OUTPUT)

exp, plantid, task, angle = 'ARCH2021-05-27', 7783, 3786, 30

index = pd.read_csv('data/grapevine/image_index.csv')
index = index[index['imgangle'].notnull()]

selec_index = index[(index['exp'] == exp) & (index['plantid'] == plantid) & (index['imgangle'] == angle)]

df_ell = pd.read_csv('X:/phenoarch_cache/cache_{0}_NEW/full_results_temporal_{0}.csv'.format(exp))
selec_ell = df_ell[(df_ell['plantid'] == plantid) & (df_ell['angle'] == angle)]

tasks = list(selec_ell.groupby('task')['timestamp'].mean().sort_values().reset_index()['task'])

# to find i_start
# [(k, len(selec_ell[(selec_ell['task'] == task) & (selec_ell['berryid'] == -1)])) for k, task in enumerate(tasks)]

# ===== time-series of images =========================================================================================

do_color = False

xmin, xmax, ymin, ymax = 300, 1100, 50, 1950
colors = [[int(k) for k in np.random.random(3) * 255.] for _ in range(max(selec_ell['berryid']) + 1)]
plt.figure()
tasks_selection = [0, 15, 26, 27, 28, 46, 47, 48, 56, 67]
for k, i_task in enumerate(tasks_selection):

    task = tasks[i_task]
    row_index = selec_index[selec_index['taskid'] == task].iloc[0]
    img_path = 'Z:/{}/{}/{}.png'.format(row_index['exp'], row_index['taskid'], row_index['imgguid'])
    img = cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB)
    img = img[ymin:ymax, xmin:xmax]

    s_ell = selec_ell[selec_ell['task'] == task]

    ax = plt.subplot(1, len(tasks_selection), k + 1)
    plt.xlabel(r'$t_{{{}}}$'.format(i_task), fontsize=15)
    plt.xticks([], [])
    plt.yticks([], [])
    for _, ell in s_ell.iterrows():
        x, y, w, h, a = ell[['ell_x', 'ell_y', 'ell_w', 'ell_h', 'ell_a']]
        lsp_x, lsp_y = ellipse_interpolation(x=x, y=y, w=w, h=h, a=a, n_points=100)
        if do_color and ell['berryid'] != -1:
            col = tuple(colors[ell['berryid']])
            img = cv2.ellipse(img, (round(x - xmin), round(y - ymin)), (round(w / 2), round(h / 2)),
                              a, 0., 360, col, -1)
            img = cv2.ellipse(img, (round(x - xmin), round(y - ymin)), (round(w / 2), round(h / 2)),
                              a, 0., 360, (0, 0, 0), 5)
        else:
            img = cv2.ellipse(img, (round(x - xmin), round(y - ymin)), (round(w / 2), round(h / 2)),
                              a, 0., 360, (255, 0, 0), 5)
    plt.imshow(img)



# ===== distance matrix ==============================================================================================

M = np.load('X:/phenoarch_cache/cache_{}_NEW/distance_matrix/{}/{}.npy'.format(exp, plantid, angle))
M2 = M[:, :, 0].copy()
for i in range(len(M)):
    for j in range(len(M)):
        if i < j:
            M2[i, j] = np.min(M[i, j][[0, 2]])
        elif i > j:
            M2[i, j] = np.min(M[i, j][[1, 2]])

# TODO : plot matrix so that [i,j] means cpd(i -> j): m becomes 2d, and not symmetric!
plt.figure()
plt.imshow(M2)
plt.rcParams.update({'font.size': 22})
set_threshold = 8
plt.plot(np.where(M2 < set_threshold)[0], np.where(M2 < set_threshold)[1], 'r.', markersize=7)
cb = plt.colorbar()
cb.set_label('D($t_i$, $t_j$)', fontsize=25)
plt.xlabel('$t_i$', fontsize=35)
plt.ylabel('$t_j$', fontsize=35)

# ===== CPD example ==================================================================================================

from deepberry.src.openalea.deepberry.temporal import scaled_cpd

points_sets = [np.array(selec_ell[selec_ell['task'] == task][['ell_x', 'ell_y']]) for task in tasks]

t1 = 47
t2 = 15

set1, set2 = points_sets[t1], points_sets[t2]
set2_bis = scaled_cpd(set1, set2, transformation='affine')
all = np.concatenate((set1, set2, set2_bis))


s1 = set1
plt.figure()
for k, s2 in enumerate([set2, set2_bis]):
    ax = plt.subplot(1, 2, k + 1)
    plt.xlim(min(all[:, 0]) - 150, max(all[:, 0]) + 150)
    plt.ylim((min(all[:, 1]) - 50, max(all[:, 1]) + 50))
    # plt.xlabel('$x_e$', fontsize=20)
    # plt.ylabel('$y_e$', fontsize=20)
    plt.xticks([], [])
    plt.yticks([], [])
    plt.gca().set_aspect('equal', adjustable='box')
    plt.plot(s2[:, 0], s2[:, 1], 'bo', mfc='none', markersize=10)
    plt.plot(s1[:, 0], s1[:, 1], 'rx', markersize=8)

# score
s1, s2 = set1, set2_bis
D = np.zeros((len(s1), len(s2)))
for k, c1 in enumerate(s1):
    D[k] = np.sqrt(np.sum((c1 - s2) ** 2, axis=1))
d = 0.5 * (np.median(np.min(D, axis=0)) + np.median(np.min(D, axis=1)))
print(d)


# ===== tree =========================================================================================================

from deepberry.src.openalea.deepberry.temporal import pairs_order

M = np.load('X:/phenoarch_cache/cache_{}_NEW/distance_matrix/{}/{}.npy'.format(exp, plantid, angle))
points_sets = [np.array(selec_ell[selec_ell['task'] == task][['ell_x', 'ell_y']]) for task in tasks]
set_threshold = 8

t_best, k_max = None, float('-inf')
for t_start in range(len(points_sets)):
    sets_pairs = pairs_order(M, i_start=t_start, threshold=set_threshold)
    k_above = [k for k, (i, j) in enumerate(sets_pairs) if np.min(M[i, j]) > set_threshold]
    k_fail = len(points_sets) - 1 if not k_above else k_above[0]
    if k_fail > k_max:
        t_best, k_max = t_start, k_fail
t_start = t_best

sets_pairs = pairs_order(M, i_start=t_start, threshold=set_threshold)


















